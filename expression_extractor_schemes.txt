ok lets go thought some possible situations,

#1  a+3*5<10 && b == 0 || c == 1

#2  (a+3)*5<10 && (b == 0 || c == 1)

#3  ((a+3)*5<10) && (b == 0 || c == 1)

#4  (a+3)*5<10 && ((b == 0) || (c == 1))

#5  (a+3)*5<10 && (b == 0) || (c == 1)

#6  ((a+3)*5<10) && (b == 0 || c == 1)

#7  b == 0 || c == 1 && a+3*5<10

#8  (b == 0 || c == 1) && (a+3)*5<10

#9  (b == 0 || c == 1) && ((a+3)*5<10)

#10 ((b == 0) || (c == 1)) && (a+3)*5<10

#11 (b == 0) || (c == 1) && (a+3)*5<10

#12 (b == 0 || c == 1) && ((a+3)*5<10)

solution for the logic/calc separation:
walk the tokenstream and push each token into a stack (tempStack)
until a logic operator is found then flush into some calc stack

here is some rules:
if a logic operator is found push it to opStack

if a logic operator is found check it's left side
and if a ) is found flush everything in tempStack until the matching ( using matchingIndex
else get everything that is in tempStack and flush as a calc expression

// please can you fill in the rest